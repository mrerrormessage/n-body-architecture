#ifndef _SERIAL_H_
#define _SERIAL_H_
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>


#define GRAV_CONST 1.000
#define TIME_STEP 0.5
#define NUM_BODIES 50
#define WORLD_X_SIZE 500.0
#define WORLD_Y_SIZE 500.0
#define GRAV_CONSTANT 6.67428e-11

struct body {
  float x_posn;
  float y_posn;
  float x_velocity;
  float y_velocity;
  float mass;
};

struct cosmos {
  int num_bodies;
  float x_world_size;
  float y_world_size;
  struct body * body_list;
  float time_step;
};


//cosmos_init initializes a cosmos with parameters as given
struct cosmos * cosmos_init(float ts, int numbodies, float xsize, float ysize);

//returns body k in cosmos c
struct body * get_body(struct cosmos * c, int k);

//cosmos_free frees a cosmos
void cosmos_free( struct cosmos * c );

//get_bodies fills the cosmos with bodies. How we're getting the bodies is very unclear at this point
//we may take away the parameter n, which tells how many bodies to fetch
//this is a dummy test function to give a sample n-body cosmos - a trivial 
//cosmos of n bodies
struct cosmos * get_cosmos( int n );

//I couldn't get the math min to work, so I used this
int min( int x, int y );

//gets the next good line, checking for EOF and ignoring whitespace and commented lines
void getnextgoodline( char * s, int n, FILE * f);

//returns a string in chunks
void chunk_string(char * s, char * delimiters, char ** result, int * numresults);

//code to read a particular body from a file. 
void read_body( struct body * b, FILE * s);

//reads a cosmos in from a filename
struct cosmos * read_cosmos( const char * filename );

//prints a body
void print_body( struct body * b);

//prints the given cosmos;
void print_cosmos( struct cosmos * c );

//gets the sign of a number
float sign( float f ){
  if (f == 0.0){
    return 0.0;
  }
  if (f < 0.0){
    return -1.0;
  }
  return 1.0;
}

void calc_gravity (struct cosmos * c, struct body * b){
  float xdiff;
  float ydiff;
  float dist_sq;
  float force;
  float dist;
  float theta;
  //  float x_accel = 0.0;
  //  float y_accel = 0.0;
  float x_force_sum = 0.0;
  float y_force_sum = 0.0;
  for(int i = 0; i < c->num_bodies; i++){
    struct body * b2;
    b2 = get_body(c, i);

    if( b2 != b ){
      xdiff = b->x_posn - b2->x_posn;
      ydiff = b->y_posn - b2->y_posn;
      //note that this is actually distance squared, but that's the term we need anyhow
      dist_sq = pow( xdiff, 2.0) + pow(ydiff, 2.0);
      force = GRAV_CONST * (b->mass) * (b2->mass) / dist_sq;
      //now we need to split it out into two separate vectors
      dist = sqrt(dist_sq);
      theta = atan(ydiff/xdiff);
      x_force_sum += force * sign(xdiff) * cos(theta);
      y_force_sum += force * sign(ydiff) * sin(theta);
    }
  }
  
  b->x_velocity += (x_force_sum / b->mass);
  b->y_velocity += (y_force_sum / b->mass);
  
  //may need to have this divided by time_step, not sure
  b->x_posn += b->x_velocity * c->time_step;
  b->y_posn += b->y_velocity * c->time_step;

  
  return;
}

//one iteration of the n_body
void simple_n_body_iter ( struct cosmos * c );

//n-body simple. 
void simple_n_body ( struct cosmos * c, int steps );


#endif
